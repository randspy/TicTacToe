package com.randspy.tictactoe.logic;

import java.util.Arrays;

public class Board {
    private static final int NUMBER_OF_COLUMNS = 3;
    private static final int NUMBER_OF_ROWS = 3;
    private static final int NUMBER_OF_BOARD_FIELDS =
            NUMBER_OF_COLUMNS * NUMBER_OF_ROWS;

    private Player[][] boardElements = new Player[NUMBER_OF_ROWS][NUMBER_OF_COLUMNS];

    public static int getNumberOfBoardFields() {
        return NUMBER_OF_BOARD_FIELDS;
    }

    public static int getNumberOfColumns() {
        return NUMBER_OF_COLUMNS;
    }

    public static int getNumberOfRows() {
        return NUMBER_OF_ROWS;
    }

    public void setPlayerAtPosition(Player player, PositionOnBoard position) {
        boardElements[position.getRow()][position.getColumn()] = player;
    }

    public boolean isFull() {

        for (int idx = 0; idx < boardElements.length; idx++) {
            for (int idy = 0; idy < boardElements[idx].length; idy++) {
                if (boardElements[idx][idy] == null) {
                    return false;
                }
            }
        }
        return true;
    }

    public Player getPlayerAtPosition(PositionOnBoard position) {
        return boardElements[position.getRow()][position.getColumn()];
    }

    //Generated by IntelljJ IDEA
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Board board = (Board) o;

        if (boardElements.length != board.boardElements.length) return false;

        for (int idx = 0; idx < boardElements.length; idx++) {
            if (!Arrays.equals(boardElements[idx], board.boardElements[idx])) return false;
        }

        return true;
    }

    //Generated by IntelljJ IDEA
    @Override
    public int hashCode() {
        return boardElements != null ? Arrays.hashCode(boardElements) : 0;
    }

    public Player[] getPlayersAtRow(int idx) {
        return boardElements[idx];
    }

    public Player[] getPlayersAtColumn(int idx) {

        return Arrays.stream(boardElements).map(row -> row[idx]).toArray(Player[]::new);
    }

    public Player[] getPlayersAtDiagonalFromLeftToRight() {
        Player [] diagonal = new Player[NUMBER_OF_COLUMNS < NUMBER_OF_ROWS ? NUMBER_OF_COLUMNS : NUMBER_OF_ROWS];

        for (int idx = 0; idx < NUMBER_OF_ROWS; idx++) {
                diagonal[idx] = boardElements[idx][idx];
        }
        return diagonal;
    }

    public Player[] getPlayersAtDiagonalFromRightToLeft() {
        Player [] diagonal = new Player[NUMBER_OF_COLUMNS < NUMBER_OF_ROWS ? NUMBER_OF_COLUMNS : NUMBER_OF_ROWS];

        int idy = NUMBER_OF_COLUMNS - 1;
        for (int idx = 0; idx < NUMBER_OF_ROWS; idx++, idy--) {
                diagonal[idx] = boardElements[idx][idy];
        }
        return diagonal;
    }
}
